/// <reference types="jest" />
declare type JMPFunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never;
}[keyof T] & string;
declare type JMPArgsType<T> = T extends (...args: infer A) => any ? A : never;
declare type JMPReturnType<T> = T extends (...args: any[]) => infer A ? A : never;
/**
 * Helper function for manually creating new spy mocks of functions not supported by this module.
 *
 * @param target Object containing the function that will be mocked.
 * @param property Name of the function that will be mocked.
 * @param impl Mock implementation of the target's function. The return type must match the target function's.
 */
export declare function spyOnImplementing<T extends {}, M extends JMPFunctionPropertyNames<T>, F extends T[M], I extends (...args: any[]) => JMPReturnType<F>>(target: T, property: M, impl: I): jest.SpyInstance<Required<JMPReturnType<F>>, JMPArgsType<F>>;
/**
 * Helper function to create a mock of the Node.js method
 * `process.exit(code: number)`.
 *
 * @param {Object} err Optional error to raise. If unspecified or falsy, calling `process.exit` will resume code
 * execution instead of raising an error.
 */
export declare const mockProcessExit: (err?: any) => jest.SpyInstance<never, [code?: number]>;
/**
 * Helper function to create a mock of the Node.js method
 * `process.stdout.write(text: string, callback?: function): boolean`.
 */
export declare const mockProcessStdout: () => jest.SpyInstance<Required<boolean>, [str: string, encoding?: string, cb?: Function]>;
/**
 * Helper function to create a mock of the Node.js method
 * `process.stderr.write(text: string, callback?: function): boolean`.
 */
export declare const mockProcessStderr: () => jest.SpyInstance<Required<boolean>, [str: string, encoding?: string, cb?: Function]>;
/**
 * Helper function to create a mock of the Node.js method
 * `process.uptime()`.
 */
export declare const mockProcessUptime: (value?: number) => jest.SpyInstance<number, []>;
/**
 * Helper function to create a mock of the Node.js method
 * `console.log(message: any)`.
 */
export declare const mockConsoleLog: () => jest.SpyInstance<void, [message?: any, ...optionalParams: any[]]>;
declare type JestCallableMocksObject = {
    [_: string]: () => jest.SpyInstance;
};
declare type JestMocksObject<T extends JestCallableMocksObject> = {
    [K in keyof T]: T[K] extends () => infer J ? J : never;
};
export interface MockedRunResult<R, M> {
    error?: any;
    result?: R;
    mocks: M;
}
/**
 * Helper function to run a synchronous function with provided mocks in place, as a virtual environment.
 *
 * Every provided mock will be automatically restored when this function returns.
 */
export declare function mockedRun<T extends JestCallableMocksObject, R>(callers: T): (f: () => R) => MockedRunResult<R, JestMocksObject<T>>;
/**
 * Helper function to run an asynchronous function with provided mocks in place, as a virtual environment.
 *
 * Every provided mock will be automatically restored when this function returns.
 */
export declare function asyncMockedRun<T extends JestCallableMocksObject, R>(callers: T): (f: () => Promise<R>) => Promise<MockedRunResult<R, JestMocksObject<T>>>;
export {};
